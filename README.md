**Next.js** 14 — это фреймворк для React, который упрощает создание современных веб-приложений. Он предоставляет множество возможностей для рендеринга на стороне сервера (SSR), генерации статических сайтов (SSG), а также для создания API.

## Базовые концепции

### 1. Структура проекта

Файловая структура проекта напрямую определяет, по каким маршрутам будет доступна та или иная страница.
```
project/
└── app/
    ├── layout.jsx       // Общий макет для страниц
    ├── page.jsx         // Главная страница     (/)
    ├── about/
    │   └── page.jsx     // Страница "О нас"     (/about)
    ├── blog/
    │   ├── page.jsx     // Страница блога       (/blog)
    │   └── [slug]/      // Динамический маршрут (/blog/123)
    │       └── page.jsx
    └── contact/
        └── page.jsx     // Страница "Контакт"   (/contact)
```

### 2. Основные файлы

 - **layout.jsx**

Используется для общего оформления страниц.
Файл `layout.jsx` представляет собой некий шаблон, который отображается на всех дочерних роутах.
`layout.jsx` расположенный в `app/` будет использоваться на всех страницах.
`layout.jsx` расположенный в `app/posts` будет использоваться только для маршрута `https://localhost:3000/posts/` и всех роутов, которые являются дочерними по отношению к роуту `posts/`, например - `https://localhost:3000/posts/new`.

```jsx
export default function Layout({ children }) {
  return (
    <html lang="en">
      <body>
        <header>My Site Header</header>
        <main>{children}</main>
        <footer>My Site Footer</footer>
      </body>
    </html>
  );
}
```

- **page.jsx**

Это основной компонент страницы.

```jsx
export default function HomePage() {
  return <h1>Welcome to My Website</h1>;
}
```

- **index.jsx**

Файл `index.jsx` в любой папке будет соответствовать корневому маршруту этой папки.
Пример: `pages/index.jsx` будет соответствовать URL `/`, а `pages/blog/index.jsx` будет соответствовать URL `/blog`.

Файлы `page.jsx`, `index.jsx`, или `layout.jsx` могут содержать специальный объект `metadata`, в который можно передавать как статические, так и динамические данные.
Эти данные попадают в тег `head` и используются для SEO и для задания заголовка(`title`) страницы в браузере.

### 3. Вспомогательные файлы.

Помимо основных файлов существуют также вспомогательные файлы - `loading.jsx, error.jsx`.

- **loading.jsx**

Файл `loading.jsx` - содержит в себе компонент - загрузочный экран.
Данный компонент как следует из названия, отображается, когда происходит загрузка данных.
И загрузка данных именно в файле `page.jsx` который находится в одной директории с файлом `loading.jsx`.

- **error.jsx**

Файл `error.jsx` - запускается автоматически если, по тому маршруту, где он расположен происходит ошибка.
Внутри него мы имеем доступ, к возникшим ошибкам, а так же можем реализовать различную логику, как пример перенаправление пользователя на исходную страницу.

### 3. Динамические маршруты

Для создания динамического маршрута используются два типа файловой структуры:
- app/pages/[slug].js - если вам нужен динамический маршрут на одном уровне;
- app/pages/[slug]/page.js - если вам нужна дополнительная вложенность для динамических маршрутов.

Динамические сегменты передаются макету, странице, роуту и функции generateMetadata в качестве пропа `params`.

- **blog/[slug]/page.js**

```jsx
export default function BlogPage({ params }) {
  const { slug } = params;
  return <h1>Blog Post: #{slug}</h1>;
}
```

Параметры запроса можно также получить с помощь хука *useSearchParams()*:

```javascript
const searchParams = useSearchParams();
const someFilter = searchParams.get('filter');
```

-  **blog/[...slug]/page**

Это обозначение для catch-all маршрутов, которые могут содержать несколько сегментов.
Пример: `pages/docs/[...slug]/page.js` будет соответствовать URL `/docs/a`, `/docs/a/b`, `/docs/a/b/c` и т.д.

- **(path)**

Это обозначение для группировки маршрутов, которое не влияет на URL.
Например, папка `(admin)` может содержать файлы, которые будут сгруппированы вместе, но не будут включены в конечный URL.
Пример: `pages/(admin)/dashboard.js` будет соответствовать URL `/dashboard`.

### 4. Клиентский компонент

Если вам нужно использовать состояние и lifecycle методы, используйте клиентский компонент:

**blog/page.js**

```javascript
'use client';

import { useState } from 'react';

export default function Blog() {
  const [posts, setPosts] = useState([]);

  return (
    <div>
      <h1>Blog</h1>
      {/* Ваш код для отображения постов */}
    </div>
  );
}
```

### 5. API маршруты

Создайте папку `api` для функций серверного API.

```
project/
└── app/
    └── api/
        └── hello/
            └── route.js
```

**api/hello/route.js**

```javascript
export async function GET() {
  return new Response('Hello, World!');
}
```

### 6. Статическая генерация и серверный рендеринг

Вы можете использовать `generateStaticParams` для генерации статических маршрутов:

**blog/[slug]/page.js**:

```javascript
export async function generateStaticParams() {
  const posts = await fetchPosts(); // ваша функция для получения постов
  return posts.map(post => ({
    slug: post.slug,
  }));
}
```

### Преимущество SSR(Server Side Rendering) перед CSR(Client Side Rendering).

1. **SEO.**
  При **SSR** на клиент отправляется уже готовая страница.
  При **CSR** - клиенту отправляется пустой HTML-файл, скрипт и данные.
  И далее уже происходит отрисовка интерфейса.
  Данный подход ухудшает индексацию данных на сайте, поисковыми роботами.

2. **Скорость загрузки.**
  Клиент при **CSR** должен скачивать много данных, в том числе и тех, которые ему не нужны на текущий момент.
  Особенно это заметно при первой загрузке данных на клиент.
  При **SSR** размер отправляемых данных меньше, т.к. часть логики остаётся на сервере и не отправляется клиенту.
  Весь код приложения автоматически разбивается на чанки и отправляется клиенту по мере необходимости.

3. **Роутинг.**
  Для **CSR** мы должны использовать вспомогательный пакет ReactRouter, чтобы реализовать роутинг в приложении.
  Для **SSR** роутинг просто выстраивается с помощью файловой структуры в папке `app/` (которая создаётся в корне Next-приложения).

4. NextJS поддерживает **SSR** и/или **SSG(Static Side Generation)**.
  Для SSG реализован механизм инкрементной регенерации статических сайтов - **Incremental Static Regeneration (ISR)**.
  Данный механизм позволяет обновлять статический контент, без полной пересборки проекта.

### Дополнение.

1. В Next-приложении, компоненты бывают 2-х видов.
   По умолчанию все компоненты в папке `app/` серверные.
   Чтобы сделать компонент клиентским, необходимо в файл (первой строкой) добавить директиву `"use client"`.

2. Компонент серверный, если в нём:
  - выполняем запрос на получение данных;
  - получаем прямой доступ к бэкенд-ресурсам;
  - храним чувствительную информацию (токены, ключи и пр);
  - если в нём используется большое количество зависимостей.

3. Компонет клиентский, если в нём:
  - есть слушатели событий (onClick, onChange etc);
  - используются реакт-хуки;
  - используется браузерный API;
  - используются классовые реакт-компоненты.

4. NextJS-приложение сочетает в себе фронтенд и бэкенд логику.
   В папке `app/` размещается папка `api/` и в ней хранится вся логика связанная с бэкендом.
   Выстраивание файловой структуры в ней аналогично, тому как создаются роуты в папке `app/`, только вместо файлов `page.js` используются файлы `route.js`.
   Endpoint-ы в файле `route.js` представляют собой функции, имена который совпадают с названием HTTP-методов - `GET, POST, PATCH` и т.д.
   Таких функций может быть несколько в `route.js`, по одной на каждый метод.


### Архитектура приложения.

- app/ - директория со страница приложения.
- app/api - api-роуты с бэкенд-логикой.
- components/ - реакт-компоненты.
- models/ - модели для взаимодействия с БД.
- public/ - статика, изображения, видео и пр.
- styles/ - файл с глобальными стилями приложения.
- utils/ - файлы с утилитарными функциями.

Формируем страницу на основе реакт-компонентов.
Там же выполняем запрос к *api* и получаем данные.
Передаём данные компонентам, получаем готовую страницу.

### Дополнительные особенности

1. **Папка `api`**:
   - Все файлы в папке `pages/api` автоматически становятся API маршрутами.
   - Пример: `pages/api/hello.js` будет соответствовать URL `/api/hello`.

   ```jsx
   // pages/api/hello.js
   export default function handler(req, res) {
     res.status(200).json({ message: 'Hello, world!' });
   }
   ```

2. **Папка `public`**:
   - Файлы в папке `public` доступны напрямую по URL.
   - Пример: `public/image.jpg` будет доступен по URL `/image.jpg`.

3. **Папка `styles`**:
   - Обычно используется для хранения файлов стилей (CSS, SCSS).


### Запуск в режиме разработки

Для запуска dev-сервера выполните следующую команду:

```bash
npm run dev
# или
yarn dev
# или
pnpm dev
```

Откройте в браузере вкладку по следующему адресу [http://localhost:3000](http://localhost:3000).

### Изучить подробнее

Больше информации о Next.js, вы сможете получить следующих ресурсах:

- [Next.js Documentation](https://nextjs.org/docs) - особенности Next.js и API.
- [Learn Next.js](https://nextjs.org/learn) - интерактивный туториал по Next.js.

### Развертывание на Vercel

Развернуть приложение можно на [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme).
Больше информации по данной теме по ссылке [Next.js deployment documentation](https://nextjs.org/docs/deployment).
